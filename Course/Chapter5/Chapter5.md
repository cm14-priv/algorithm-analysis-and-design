# 第五章：状态空间的各种搜索

## 	1 概述

* **纯随机搜索法(Random Generation and Random Walk)：**对于深度大，可行解较多而解的深度又不重要时用。适用于解分布较有规律的题目，如相对密集或平均、或按黄金分割比例分布等；
* **广度优先搜索法(BFS)：**以接近起始节点的程度依次扩展节点，即对下一层节点搜索前，必须先搜索完本层所有节点
* **深度优先搜索法(DFS)：**首先扩展最新产生的节点，每层只对一个节点进行扩展，除非搜索失败或已达到预先约定的最大深度，才会退回去搜索原来忽略节点


![image](https://cloud.githubusercontent.com/assets/7693440/11356511/66f3060a-9299-11e5-8da7-7ea86580d9e5.png)

## 2 广度优先搜索（BFS）

1. 定义:树上节点的扩展是沿着深度的“断层”进行的,即要对下一深度的任一节点进行搜索扩展之前,先要对当前(层)深度的每一个节点进行搜索,这种搜索能保证找到步数最少；
> 如果代价和搜索树深度成正比，通常可用BFS获解，但其占用空间大，但比深度优先搜索要快。

2. 算法:
```cpp
(1)把初始节点放入待扩展节点的open表中,此表开始只有起始节点,其结构为队结构(先进先出),节点是先产生先扩展
(2)如表open空(即待扩展节点已全部扩展完), 退出
(3)把open表中队列前的节点取出,按合适的途径扩展全部子节点,并把新产生的子节点依次加入open表后,同时提供子节点返回父节点指针,若无子节点返回(2)
(4)如果有任一子节点为目标节点,则找到一个解,打印路径,退出返回(2)
```

**例1**

有一个瓶中装有80ml红酒,实验中需要把它精确地平分成两份,没有量具,只有两杯子容量分别为50ml和30ml,编程求将红酒平分的过程.

![image](https://cloud.githubusercontent.com/assets/7693440/11357419/37a6dbf2-92a2-11e5-9367-c617a22f1bbb.png)

## 3 深度优先搜索（DFS）

* 首先扩展最新产生的节点,使搜索沿着状态空间某条单一路径从起始节点向下进行,只有搜索到没有子节点产生时,才考虑另一条替换路径,且替换路径应先选与原路径差异最小的.为避免路径太长,防止搜索过程沿无益路径扩展下去,往往给出节点扩展最大深度.如任何节点达到深度界限,可作为没有子节点的节点处理,不再深入搜索下去.

* 按深度优先搜索的顺序遍历状态空间，通常用递归或栈来实现。

**例2**

8数码问题

![image](https://cloud.githubusercontent.com/assets/7693440/11357452/69269816-92a2-11e5-8d9e-bedfff8c54db.png)

![image](https://cloud.githubusercontent.com/assets/7693440/11357457/7367da9c-92a2-11e5-88b7-6070f849e723.png)

**作业**

* 完成8数码问题
* 已知:给定的源状态,求出要求的目标态

* 深优可用栈来存储节点,每生成一个节点就放入栈中(除了已经达到限定深度的节点外,因达到限定深度节点无需再扩展),每次我们选栈顶节点再进行扩展,直至找到目标节点为止.
```cpp
扩展顺序  扩展前栈内节点标号  选取扩展节点标号
	1		1                  1
	2		2,3,4,5		    5
	3		2,3,4,6,7		  7
	4		2,3,4,6,8		  8
	5		2,3,4,6			6
	6		2,3,4,11		   11
	7		2,3,4			  4
	8		2,3,14,15		  15
	9		2,3,14,16		  16
    10	   2,3,17,18		  18
```

**深优搜索算法:**
```cpp
(1)从初始节点开始,将待扩展节点依次放到open中(后进先出)
(2)如表open空,即所有待扩展节点已全部扩展完毕,则退出
(3)取open表中最新加入的节点,即栈顶节点出栈,按适当规则扩展所有子节点,同时记录这些节点的父指针,并将这些节点依次放入open表中.若无子节点,返回(2)
(4)如某一子节点为目标节点,则求得解.沿指针所示,打印路径.若只需要一个解,则退出.否则返回(2)继续搜索新的目标节点.
```

**例3**

开连环锁问题.有一把锁,在它的锁销上有N个环,如果让这N个环都拆下来锁就被打开.但拆环和装环必须遵循下列规则

(1)第一个环可以随意装拆
(2)第二个环只有在第一个环已装上时才可装拆
(3)第N个环只有在第N-1个环已装上,且第N-2个,第N-3个,…,第1个环均已拆下时才可装拆

试编程描述把锁打开的过程.

**解题思路:深优或者递归**
```cpp
深优:设N=4
(1).初态1，环都装上
(2).由1可有两种：拆第2环获状态2；
                          拆第1环获状态3
(3).用栈存放，1态先送栈,2态再送,后送3态.深优规定每次选栈顶节点扩展,故先扩展3态
(4).拆第3环得4压栈(或装第1环,则回复1态,删去)
(5).装第1环得5压栈
(6).拆第2环得6压栈
(7).拆第1环得7压栈
(8).7态无法再扩展成目标态,故7态出栈,6态为栈顶,依次5,4,3出栈
(9).2态为栈顶获8态
(10).扩展成9态->10态->11态->12态->13态->14态->15态->16态
```

![image](https://cloud.githubusercontent.com/assets/7693440/11357532/147ab81e-92a3-11e5-9bde-713afc37796e.png)

## 4 搜索的优化

* 缩小问题的状态空间
* 在广度优先搜索算法中，扩展存储结点的内存空间
* 根据问题的约束条件，在搜索中剪枝
* 利用搜索过程中的中间解
* 进行解变换
* 寻找问题的隐性条件
* 问题分治

## 5 王伯买鱼

王伯希望用他有限的资金去购买尽可以有多的鱼，请写一个程序帮助王伯。

输入格式：输入文件的第一行为两个正整数M（M<=1000），N（N <=30），分别表示王伯的资金和鱼的种类。以下N行，每行有两个正整数S（1 <= S <= N），T ，分别表示某种鱼的编号以及该鱼的价格。

接着，每行有两个整数P，Q。当P，Q均大于0时，表示P，Q不能共处；当P，Q均等于0时，表示输入文件的结束。

**输出格式：**

输出文件的第一行为两个正整数X，Y，分别表示所买鱼的条数和总花费。以下X行，每行有一个正整数，表示所买鱼的编号。编号按升序排列输出。

如果题目有多个解，只需输出其中的一个。

* 规定
	* 最多30种鱼
	* 对于每种鱼，最多只能买一条
	* 有些鱼不能一起买
	* 每条鱼有一定价钱，王伯的资金有限
* 目标
	* 买尽可能多的鱼

![image](https://cloud.githubusercontent.com/assets/7693440/11357581/930a6436-92a3-11e5-86a1-36a1cd954a11.png)

* 用集合表示王伯买了哪些鱼
	* 表：List = {1, 2, 4, …}
	* 向量：Vector = {1, 1, 0, 1, …}
	* 计算机的数组：int got[30];
		* got[i] = 1 表示买了第i条鱼
		* got[i] = 0 否则

![image](https://cloud.githubusercontent.com/assets/7693440/11357604/d578a6c0-92a3-11e5-8b0a-dadb6b93353f.png)

```cpp
void buy ( i )
    if (i>n) 找到一个子集;
    else
        got[i] = 0;
        buy( i+1 );
        if ( i能与已买的鱼共处 && 还有钱支付 )
            got[i] = 1; 并支付鱼的价钱;
            buy( i+1 );
            got[i] = 0; 并取回鱼的价钱;
```

* 有n种鱼：2n个子集
	* 230 = 1,073,741,824
* 把不必要的子集删除
	* 可行性：发生冲突、不够钱
	* 最优化：估算剩下的鱼，最多可以取多少

![image](https://cloud.githubusercontent.com/assets/7693440/11357629/1e4f8134-92a4-11e5-8bdc-5fe1848e0d36.png)

* 不考虑价格，最多能买多少的鱼？
* 删除多少个顶点后剩下的图没有边
	* 尽可能删度数大的顶点
	* 2*边数 = Σ顶点度
	* 认为删一个点就可以删与之度数相同的边数
		{3, 2, 2, 2, 1, 1, 1}

![image](https://cloud.githubusercontent.com/assets/7693440/11357636/35dacfe8-92a4-11e5-9c51-0c27828fda94.png)

## 6 等代价搜索

在等代价搜索中,每一节点之间的连线上都有两节点间代价值.若题目要求解最小代价路径时,可使用等代价搜索法.它沿着等代价路径断层进行扩展.其特殊情况是所有连线上的代价都相同,等代价搜索为宽度优先搜索.

* 设定:i节点到j节点代价为m(i,j)
	* 起始节点为s到节点i的代价为cost(i)
    * 搜索时按cost(i)递增顺序扩展其节点
* 算法：
```cpp
(1)把起始节点s放入open表中(待扩展节点表)，令cost(s)=0
(2)如open表空，则退出
(3)从open表中选择一个节点i，要求cost(i)最小，如i非目标节点，将i节点移出open表，并扩展其子节点
(4)对i的每一个子节点j，计算cost(j)=cost(i)+m(i,j),并把这些子节点放入open表中，同时记录j的父指针后返回(2)
扩展规则：按代价值大小选取节点进行扩展
```

* 设定:i节点到j节点代价为m(i,j)
	* 起始节点为s到节点i的代价为cost(i)
	* 搜索时按cost(i)递增顺序扩展其节点
* 算法：
```cpp
(1)把起始节点s放入open表中(待扩展节点表)，令cost(s)=0
(2)如open表空，则退出
(3)从open表中选择一个节点i，要求cost(i)最小，如i非目标节点，将i节点移出open表，并扩展其子节点
(4)对i的每一个子节点j，计算cost(j)=cost(i)+m(i,j),并把这些子节点放入open表中，同时记录j的父指针后返回(2)
扩展规则：按代价值大小选取节点进行扩展
```

**例5**

假设A,B,C,D,E各个城市之间旅费如下表所列。左边一列是起点，上面一行是终点，即从A到B旅费为7，B到A的旅费为6.某人想从一个城市出发游览各城市一遍，再回到出发地，而所用旅费最少.试编一程序，求出从各地出发回到出发地的所有最佳路线。

```cpp
            A    B   C     D     E
       A    0    7    3    10   15
       B    6    0    5    13   12
       C    4    8    0    5    10
       D    9    1    6    0    11
       E    17  14    9    8     0
```

**分析：**

城市间旅费=节点间代价，制约条件是代价最小，先扩展代价最小的节点。如从A->B->E，cost(B)=7,cost(E)=cost(B)+m(B,E)=7+12=19.设计以A为起点，用等代价搜索得出部分搜索树，连线上数字为从父节点到子节点的代价.节点上方小圆圈内数字为节点扩展顺序，方框左上方为从A到该节点总代价.

![image](https://cloud.githubusercontent.com/assets/7693440/11367167/e81c6908-92ec-11e5-9d2e-6e6d4ea6c50c.png)

## 7 A*算法

所谓A*算法是优先对那些最有希望的节点进行扩展，也即这种搜索必须引进一个估计节点”搜索价值”的量度函数(也叫估价函数)，估价函数由起始节点到该节点的一条最佳路径的实际代价与该节点到目标节点的一条最佳路径的估计代价之和组成.节点n估价函数为：


![image](https://cloud.githubusercontent.com/assets/7693440/11367192/0be5a804-92ed-11e5-82d9-5009e305fd9b.png)

* 估价函数的启发能力常通过简单乘以大于1正整数而加以提高，故有
   guesscost(n)=cost(n)+H*guess(n)
   H值过大，会过分地强调启发分量，
   H值过小，会变成等代价搜索

```cpp
(1)从起始节点s开始，将待扩展节点放入待扩展节点表(open表)中，并令cost(s)=0
(2)若open表空，则退出
(3)从open表中，选取具有最小guesscost值的节点b移出open表，若b为目标节点，则获一解，退出，如要求多解，则转(2)继续

(4)若b不为目标节点，则扩展其子节点，若无子节点，返回(2)，否则对所扩展的所有子节点作如下处理：

i)对b生成的节点i，计算从起始节点到该节点的实际代价和估价函数值.
    cost(i)=cost(b)+m(b,i) 其中m(b,i)为b节点到i节点的代价
    guesscost(i)=cost(i)+guess(i)*H
    
ii)对重复产生的子节点D，比较从起点节点经新路径到达该点的代价与旧路径到该点的代价，若不小于(即cost(D新)>=cost(D旧))，则删除此节点，否则对D及相关节点的父指针及cost值进行调整(以新指针及新cost值取代之)

iii)对新产生子节点，设定指向父辈节点的指针，按guesscost值大小添加到open表中适当位置

(5)返回(2)继续
```

**例：**
炸迷宫问题
```cpp
	有一个N*N迷宫，每一格或是空，或者是实，如果有一人位于迷宫的一空格(x,y)中，则他仅能到达相邻的空格(指上下左右).现有一人从(1,1)始点出发，目标是(N,N)，他随身带着K个炸弹(0<=K<=N)，一个炸弹的威力能把与他相邻的一个实格炸成空格.
    编一程序，求出R个被炸实格位置(0<=R<=K)和此人从起始点到目标的路径，并要求R满足条件中的最小值.

要求：

(1)输入 N*N的迷宫时，应先画出一个全是实格的迷宫(如图)，B表示实格，N应足够大 (N>=7)
(2)该迷宫能由使用者移动光标选择任一点，并能通过某一个键(自定义)使此格由实格变空或者由空变实(图2)
(3)完成题所要求的任务，输出结果应显示被炸格及路径.(图3)
```

![image](https://cloud.githubusercontent.com/assets/7693440/11367271/83546c2c-92ed-11e5-8b3f-3f51b8a90552.png)

* 在A*算法中，估价函数
```cpp
guesscost(n)=cost(n)+guess(n)*H
cost(n)=从(1,1)到格n的实际代价，即为走过空格总数+实格总数*100
guess(n)=格n到目标节点距离.例如n为(3,2),目标是(5,5),则guess(n)=(5-3)+(5-2)=5
```

![image](https://cloud.githubusercontent.com/assets/7693440/11367297/a8c8e7da-92ed-11e5-9db4-ccbe8e1898df.png)

## 8 分枝限界法

* 设计策略：利用分枝限界的方法构造一棵搜索树，求出搜索树中每个节点上的实际花费函数，找出花费函数的极大(小)值.也即分枝限界法是建立一个局部路径(或分枝)的队列，每次都优先扩展当前具有最大(小)消耗值分枝路径的端节点n(其估价函数为f(n)=g(n)),直到生成含有目标节点的路径.

* 例：图中各点间连线表示从一处到另一处所消耗的费用，试编一程序求任意两地之间的最小费用(代价最小)的路线，并打印所付出费用.

![image](https://cloud.githubusercontent.com/assets/7693440/11367323/d59da048-92ed-11e5-93d3-67ccf9f698d8.png)


![image](https://cloud.githubusercontent.com/assets/7693440/11367341/f2d7c1ac-92ed-11e5-984c-357c3682c355.png)

设求从v1->v5所付出代价最小路径
设变量s=从始点到某点总代价
* (1)第一步扩展v1获得第一级子节点:
```cpp
    v1->v2:2
    v1->v3:4
    V1->v4:5
```
* (2)第二步扩展v2，获得第二级子节点v3,v7
```cpp
    此时各条路径总代价
    v1->v2->v3:3
    v1->v2->v7:8
    v1->v3:4
    v1->v4:5
    选4条路径中代价最小的一条优先扩展，即v1->v2->v3
```
* (3)第三步扩展v3，获第三级子节点v4,v5
```cpp
    此时各条路径总代价
    v1->v2->v3->v4:7
    v1->v2->v3->v5:6,到达目的节点，但可能不是最小代价
    v1->v3:4
    v1->v4:5
    再选费用最小路径v1->v3来扩展
```
* (4)第四步扩展v3,第二级子节点:v2,v4,v5
```cpp
    其各路径总代价为：
    v1->v2->v3->v4:7
    v1->v2->v3->v5:6
    v1->v2->v7:8
    v1->v3->v2:5
    v1->v3->v4:8
    v1->v3->v5:7
    v1->v4:5
    选最小费用路径v1->v3->v2及v1->v4优先扩展这两条路径
```
* (5)第五步优先扩展v2,v3,得v1->v3->v2的第二级子节点v7,v1->v4的第二级子节点v3,v6
```cpp
    扩展后各条路经总代价是
    v1->v2->v3->v4:7
    v1->v2->v3->v5:6 该路经已到达目标节点，且为最小代价，
   故v1->v2->v3->v5为所求
    v1->v2->v7:8
    v1->v3->v2->v7:11
    v1->v3->v4:8
    v1->v3->v5:7
    v1->v4->v3:9
    v1->v4->v6:11
```

## 9 作业

1317 Sudoku,数独，求解的个数
1215 脱离地牢，BFS
1180 先将10 个串排列，再搜索
1050 用DFS做（第二章中用回溯）
1171 DFS枚举棋盘后检测
1219 新红黑树，博弈
1048 BFS二进制表示状态
1135 飞越田野，BFS
1107 按题意搜索，输出排序
