# 第五章：状态空间的各种搜索

## 	1 概述

* **纯随机搜索法(Random Generation and Random Walk)：**对于深度大，可行解较多而解的深度又不重要时用。适用于解分布较有规律的题目，如相对密集或平均、或按黄金分割比例分布等；
* **广度优先搜索法(BFS)：**以接近起始节点的程度依次扩展节点，即对下一层节点搜索前，必须先搜索完本层所有节点
* **深度优先搜索法(DFS)：**首先扩展最新产生的节点，每层只对一个节点进行扩展，除非搜索失败或已达到预先约定的最大深度，才会退回去搜索原来忽略节点


![image](https://cloud.githubusercontent.com/assets/7693440/11356511/66f3060a-9299-11e5-8da7-7ea86580d9e5.png)

## 2 广度优先搜索（BFS）

1. 定义:树上节点的扩展是沿着深度的“断层”进行的,即要对下一深度的任一节点进行搜索扩展之前,先要对当前(层)深度的每一个节点进行搜索,这种搜索能保证找到步数最少；
> 如果代价和搜索树深度成正比，通常可用BFS获解，但其占用空间大，但比深度优先搜索要快。

2. 算法:
```cpp
(1)把初始节点放入待扩展节点的open表中,此表开始只有起始节点,其结构为队结构(先进先出),节点是先产生先扩展
(2)如表open空(即待扩展节点已全部扩展完), 退出
(3)把open表中队列前的节点取出,按合适的途径扩展全部子节点,并把新产生的子节点依次加入open表后,同时提供子节点返回父节点指针,若无子节点返回(2)
(4)如果有任一子节点为目标节点,则找到一个解,打印路径,退出返回(2)
```

**例1**

有一个瓶中装有80ml红酒,实验中需要把它精确地平分成两份,没有量具,只有两杯子容量分别为50ml和30ml,编程求将红酒平分的过程.

![image](https://cloud.githubusercontent.com/assets/7693440/11357419/37a6dbf2-92a2-11e5-9367-c617a22f1bbb.png)

## 3 深度优先搜索（DFS）

* 首先扩展最新产生的节点,使搜索沿着状态空间某条单一路径从起始节点向下进行,只有搜索到没有子节点产生时,才考虑另一条替换路径,且替换路径应先选与原路径差异最小的.为避免路径太长,防止搜索过程沿无益路径扩展下去,往往给出节点扩展最大深度.如任何节点达到深度界限,可作为没有子节点的节点处理,不再深入搜索下去.

* 按深度优先搜索的顺序遍历状态空间，通常用递归或栈来实现。

**例2**

8数码问题

![image](https://cloud.githubusercontent.com/assets/7693440/11357452/69269816-92a2-11e5-8d9e-bedfff8c54db.png)

![image](https://cloud.githubusercontent.com/assets/7693440/11357457/7367da9c-92a2-11e5-88b7-6070f849e723.png)

**作业**

* 完成8数码问题
* 已知:给定的源状态,求出要求的目标态

* 深优可用栈来存储节点,每生成一个节点就放入栈中(除了已经达到限定深度的节点外,因达到限定深度节点无需再扩展),每次我们选栈顶节点再进行扩展,直至找到目标节点为止.
```cpp
扩展顺序  扩展前栈内节点标号  选取扩展节点标号
	1		1                  1
	2		2,3,4,5		    5
	3		2,3,4,6,7		  7
	4		2,3,4,6,8		  8
	5		2,3,4,6			6
	6		2,3,4,11		   11
	7		2,3,4			  4
	8		2,3,14,15		  15
	9		2,3,14,16		  16
    10	   2,3,17,18		  18
```

**深优搜索算法:**
```cpp
(1)从初始节点开始,将待扩展节点依次放到open中(后进先出)
(2)如表open空,即所有待扩展节点已全部扩展完毕,则退出
(3)取open表中最新加入的节点,即栈顶节点出栈,按适当规则扩展所有子节点,同时记录这些节点的父指针,并将这些节点依次放入open表中.若无子节点,返回(2)
(4)如某一子节点为目标节点,则求得解.沿指针所示,打印路径.若只需要一个解,则退出.否则返回(2)继续搜索新的目标节点.
```

**例3**

开连环锁问题.有一把锁,在它的锁销上有N个环,如果让这N个环都拆下来锁就被打开.但拆环和装环必须遵循下列规则

(1)第一个环可以随意装拆
(2)第二个环只有在第一个环已装上时才可装拆
(3)第N个环只有在第N-1个环已装上,且第N-2个,第N-3个,…,第1个环均已拆下时才可装拆

试编程描述把锁打开的过程.

**解题思路:深优或者递归**
```cpp
深优:设N=4
(1).初态1，环都装上
(2).由1可有两种：拆第2环获状态2；
                          拆第1环获状态3
(3).用栈存放，1态先送栈,2态再送,后送3态.深优规定每次选栈顶节点扩展,故先扩展3态
(4).拆第3环得4压栈(或装第1环,则回复1态,删去)
(5).装第1环得5压栈
(6).拆第2环得6压栈
(7).拆第1环得7压栈
(8).7态无法再扩展成目标态,故7态出栈,6态为栈顶,依次5,4,3出栈
(9).2态为栈顶获8态
(10).扩展成9态->10态->11态->12态->13态->14态->15态->16态
```

![image](https://cloud.githubusercontent.com/assets/7693440/11357532/147ab81e-92a3-11e5-9bde-713afc37796e.png)

## 4 搜索的优化

* 缩小问题的状态空间
* 在广度优先搜索算法中，扩展存储结点的内存空间
* 根据问题的约束条件，在搜索中剪枝
* 利用搜索过程中的中间解
* 进行解变换
* 寻找问题的隐性条件
* 问题分治

## 5 王伯买鱼

王伯希望用他有限的资金去购买尽可以有多的鱼，请写一个程序帮助王伯。

输入格式：输入文件的第一行为两个正整数M（M<=1000），N（N <=30），分别表示王伯的资金和鱼的种类。以下N行，每行有两个正整数S（1 <= S <= N），T ，分别表示某种鱼的编号以及该鱼的价格。

接着，每行有两个整数P，Q。当P，Q均大于0时，表示P，Q不能共处；当P，Q均等于0时，表示输入文件的结束。

**输出格式：**

输出文件的第一行为两个正整数X，Y，分别表示所买鱼的条数和总花费。以下X行，每行有一个正整数，表示所买鱼的编号。编号按升序排列输出。

如果题目有多个解，只需输出其中的一个。

* 规定
	* 最多30种鱼
	* 对于每种鱼，最多只能买一条
	* 有些鱼不能一起买
	* 每条鱼有一定价钱，王伯的资金有限
* 目标
	* 买尽可能多的鱼

![image](https://cloud.githubusercontent.com/assets/7693440/11357581/930a6436-92a3-11e5-86a1-36a1cd954a11.png)

* 用集合表示王伯买了哪些鱼
	* 表：List = {1, 2, 4, …}
	* 向量：Vector = {1, 1, 0, 1, …}
	* 计算机的数组：int got[30];
		* got[i] = 1 表示买了第i条鱼
		* got[i] = 0 否则

![image](https://cloud.githubusercontent.com/assets/7693440/11357604/d578a6c0-92a3-11e5-8b0a-dadb6b93353f.png)

```cpp
void buy ( i )
    if (i>n) 找到一个子集;
    else
        got[i] = 0;
        buy( i+1 );
        if ( i能与已买的鱼共处 && 还有钱支付 )
            got[i] = 1; 并支付鱼的价钱;
            buy( i+1 );
            got[i] = 0; 并取回鱼的价钱;
```

* 有n种鱼：2n个子集
	* 230 = 1,073,741,824
* 把不必要的子集删除
	* 可行性：发生冲突、不够钱
	* 最优化：估算剩下的鱼，最多可以取多少

![image](https://cloud.githubusercontent.com/assets/7693440/11357629/1e4f8134-92a4-11e5-8bdc-5fe1848e0d36.png)

* 不考虑价格，最多能买多少的鱼？
* 删除多少个顶点后剩下的图没有边
	* 尽可能删度数大的顶点
	* 2*边数 = Σ顶点度
	* 认为删一个点就可以删与之度数相同的边数
		{3, 2, 2, 2, 1, 1, 1}

![image](https://cloud.githubusercontent.com/assets/7693440/11357636/35dacfe8-92a4-11e5-9c51-0c27828fda94.png)

## 6 等代价搜索

在等代价搜索中,每一节点之间的连线上都有两节点间代价值.若题目要求解最小代价路径时,可使用等代价搜索法.它沿着等代价路径断层进行扩展.其特殊情况是所有连线上的代价都相同,等代价搜索为宽度优先搜索.

* 设定:i节点到j节点代价为m(i,j)
	* 起始节点为s到节点i的代价为cost(i)
    * 搜索时按cost(i)递增顺序扩展其节点
* 算法：
```cpp
(1)把起始节点s放入open表中(待扩展节点表)，令cost(s)=0
(2)如open表空，则退出
(3)从open表中选择一个节点i，要求cost(i)最小，如i非目标节点，将i节点移出open表，并扩展其子节点
(4)对i的每一个子节点j，计算cost(j)=cost(i)+m(i,j),并把这些子节点放入open表中，同时记录j的父指针后返回(2)
扩展规则：按代价值大小选取节点进行扩展
```


