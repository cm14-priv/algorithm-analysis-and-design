# 第三章 基础算法

## 1 枚举算法

* 所谓枚举算法，是指从可能的集合中一一枚举各元素，用题目给定的检验条件判定哪些是有用的，哪些是无用的。能使命题成立者，即为问题的解。

* 采用枚举算法解题的基本思路如下：
（1）建立问题的数学模型，确定问题的可能解的集合（可能解的空间）。
（2）逐一枚举可能解集合中的元素，验证是否是问题的解。

使用伪代码可以描述为：
```cpp
for each s in S	//S是问题所有可能解的集合
   if s is a solution then
     begin
        Write(s);
        exit the program;
     end;
```

**例3.1：**

寻找水仙花数

一个三位数其各位数字的立方和等于它本身，这样的数称为水仙花数。要求找出所有的水仙花数

分析：所求一定是三位数，所以范围一定在100-999之间，只要将这些数逐一列举，符合条件者为解

```cpp
For a:=100  to 999 do {
    b:=a mod 10;  //取出个位
    c:=(a div 10) mod 10 //取出十位
    d:＝ a div 100 //取出百位
    if (a=b*b*b+c*c*c+d*d*d) then writeln(a)
}
```

* 分析 :按照枚举算法的思路，首先应该构造可能解的集合：S={(x,y,z)|0≤x,y,z≤100}，其中三元组(x,y,z)表示买公鸡x只，母鸡y只和小鸡z只。因为一共需要买100只鸡，因此，买公鸡、母鸡和小鸡的数量都不会超过100。然后确定验证解的条件：x+y+z=100 and 3x+2y+z/3=100。

* 下面是解这百鸡问题的程序：

```cpp
    Program ex3_1_1;

    Var  x,y,z:integer;

    begin //枚举可能解空间的元素
    for x:=0 to 100 do
        for y:=0 to 100 do
            for z:=0 to 100 do
            if (x+y+z=100) and (x*3+y*2+z　div 3=100) and (z mod 3=0)  then
            	WriteLn(Format('(x,y,z)=(%3d,%3d,%3d)',[x,y,z]));
    end.
```

**程序输出结果为：**
```cpp
(x,y,z)=(  0, 40, 60)
(x,y,z)=(  5, 32, 63)
(x,y,z)=( 10, 24, 66)
(x,y,z)=( 15, 16, 69)
(x,y,z)=( 20,  8, 72)
(x,y,z)=( 25,  0, 75)
```
> 有6种可选的方案。

* 程序需要循环100^3，即|S|=100^3。我们通过条件x+y+z=100来约束求解空间，缩小可能解的集合的规模：
```cpp
Program ex3_1_2;
	　．．．．．．
begin
      //枚举可能解空间的元素
        for (x=0;x<=100;x++)
         for (y=0;y<=100-x;y++) 
	    begin
          z:=100-x-y;
		　if (x+y+z=100) and (x*3+y*2+z div 3=100) and (z mod 3=0) 
             ．．．．．．
	   end;
end.
```

* 程序ex3_1_2的运行结果和程序ex3_1_1相同，但是循环次数为（100*101/2），是程序ex3_1_1循环次数的1/200左右。

* 枚举算法适用范围：
```cpp
简单数值判断题；
简单逻辑判断题；
数据规模不大的问题；
没有想到更好解法的题，可用枚举求出一定范围内的解。
对于枚举算法，程序优化的主要考虑方向是：通过加强约束条件，缩小可能解的集合的规模。
```

## 2 回溯算法

* 所谓的回溯技术就是像人走迷宫一样，先选择一个前进方向尝试，一步步往前试探，在遇到死胡同不能再往前的时候就回退到上一个分叉点，选另一个方向尝试，而在前进和回撤的路上都设置一些标记，以便能正确返回，直到达到目标或者所有的可行方案都已经尝试完为止。
* 在通常的情况下，我们使用递归方式来实现回溯技术，也就是在每一个分叉点进行递归尝试。在回溯时通常采用栈来记录回溯过程，使用栈可使穷举过程能回溯到所要位置，并继续在指定层次上往下穷举所有可能的解。

* 回溯算法可以用伪码描述如下：
```cpp
  Proc Search(当前状态);
  begin
      If  当前状态等于目标状态 then exit;
      for 对所有可能的
          Search(新状态)；
  end;
```

* 回溯算法是一种十分常用的算法，象一些经典问题如八皇后问题、骑士周游问题、地图着色问题都可以采用回溯算法来解。

**例题：**

求马的不同走法总数问题描述：在一个4*5的棋盘上，马的起始位置坐标（纵，横）位置由键盘输入，求马能返回初始位置的所有不同走法的总数(马走过的位置不能重复，马走“日”字)。

**算法分析：**

由于棋盘的大小只有4*5，所以只需使用回溯算法，搜索马能返回初始位置的所有不同走法，效率基本上能达到要求。

* 递归的回溯算法可描述为：

```cpp
 procedure search(now:position); {now是当前位置}
    begin
        for 马从当前位置now出发走一步到位置next的每一种走法 do begin
            if next在棋盘内 and next位置没有走过 then
            	if next=出发点 then 不同走法总数加1
            	else begin
                	标记next已经走过了;
                	search(next);
                	取消位置next的标记;
            end;
        end;
    end;
```

* 棋盘用坐标表示，点P(x,y)表示棋盘上任一个点，x,y的范围是：1<=x<=4，1<=y<=5。
* 从P(x,y)出发，下一步最多有8个位置，记为P1，P2，……,P8，若用k表示这8个方向，则k=1,2,…,8。即马从P点出发，首先沿k=1的方向行进，当在此方向走完所有的不同走法后，就进行回溯，改变k=2方向继续行进……

* 各点坐标的计算。设P点坐标为(x,y)，则能到达点的坐标分别为P1(x+1,y-2)，P2(x+2,y-1)，…，P7(x-2,y-1)，P8(x-1,y-2)。为简化坐标的计算，引入增量数组：
```cpp
direction:array[1..8] of position=
     ((x:1;y:-2),(x:2;y:-1),(x:2;y:1),(x:1;y:2)
	 (x:-1;y:2),(x:-2;y:1),(x:-2;y:-1),(x:-1;y:-2)); 
```

    ![image](https://cloud.githubusercontent.com/assets/7693440/11372699/dad6b358-9309-11e5-8998-91af54ec3e44.png)

则按方向k能到达点的坐标是：
`Pk(x+direction[k].x,y+direction[k].y)。`
程序如下：

```cpp
program ex3_2;

type position=record  x,y:integer; end;

const direction:array[1..8] of position=
       ((x:1;y:-2),(x:2;y:-1),(x:2;y:1),(x:1;y:2),
       (x:-1;y:2),(x:-2;y:1),(x:-2;y:-1),(x:-1;y:-2));

var pass:array [1..4,1..5] of integer;

start:position;
total:integer;

procedure search(now:position); {now是当前位置}
    var i:integer;
    	next:position;
    begin
    	for i:=1 to 8 do begin
    		next.x:=now.x + direction[i].x;
    		next.y:=now.y + direction[i].y;
    		if (next.x>=1) and (next.x<=4) and (next.y>=1) and (next.y <= 5) and (pass[next.x,next.y]=0) then
    			if (next.x=start.x) and (next.y=start.y) then
    				inc(total)
    			else begin
    				pass[next.x,next.y]:=1;
    				search(next);
    				pass[next.x,next.y]:=0;
    			end;
    	end;
    end;
    begin
            total:=0;
            fillchar(pass,sizeof(pass),0);
            write('Start position:');
            readln(start.x,start.y);
            search(start);
            writeln('Total=',total);
            readln;
    end.
```

**作业3.1**
Sicily 1152 简单的马周游问题

* 在一个5 * 6的棋盘中的某个位置有一只马，如果它走29步正好经过除起点外的其他位置各一次，这样一种走法则称马的周游路线，试设计一个算法，从给定的起点出发，找出它的一条周游路线。

* 为了便于表示一个棋盘，我们按照从上到下，从左到右对棋盘的方格编号，如下所示：
```cpp
1	 2	 3	 4	 5	 6
7	 8	 9	 10	11	12
13	14	15	16	17	18
19	20	21	22	23	24
25	26	27	28	29	30
```

* 马的走法是“日”字形路线，例如当马在位置15的时候，它可以到达2、4、7、11、19、23、26和28。但是规定马是不能跳出棋盘外的，例如从位置1只能到达9和14。

* [输入] 标准输入stdin

> 输入有若干行。每行一个整数N(1<=N<=30)，表示马的起点。最后一行用-1表示结束，不用处理。

4
8
15
-1

* [输出] 标准输出 stdout
* 对输入的每一个起点，求一条周游线路。对应地输出一行，有30个整数，从起点开始按顺序给出马每次经过的棋盘方格的编号。相邻的数字用一个空格分开。
* 注意：如果起点和输入给定的不同，重复多次经过同一方格或者有的方格没有被经过，都会被认为是错误的

## 3 贪心算法

* 所谓贪心算法是指：在对问题求解时，总是作出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，它所做出的仅是在某种意义上的局部最优解。
* 贪心算法不是对所有问题都能得到整体最优解，但对范围相当广泛的许多问题它能产生整体最优解或者是整体最优解的近似解。
* 贪心算法时间复杂度较低，算法较易实现。

* 采用贪心算法的基本思路如下：
（1）建立数学模型来描述问题。
（2）把求解的问题分成若干个子问题。
（3）对每一子问题求解，得到子问题的局部最优解。
（4）把子问题的局部最优解合成原求解问题的一个解。

**例3.3.1：**

无向图的最小生成树问题。

设G=[V,E]是一个无向图，如果T=[V,E]是由G的全部顶点及其一部分边组成的子图，T是树，则称T是G的一个生成树。记L（T）为T的长度，即树T的各边之和。求G的所有生成树中L（T）最小的生成树。

图3.3.1无向图G及其生成树：
下面的两棵树都是图G的生成树，其中T2是所有图G的最小的生成树。



