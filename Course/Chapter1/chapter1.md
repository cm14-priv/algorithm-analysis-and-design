# 第一章 算法设计常用到的基本策略

## 1 程序的灵魂

* 数据结构+算法=程序
* 算法设计思想
* 算法分析：从时空、适用范围来分析，重点考虑时间效率和空间开销
* 复杂度分析
* 复杂度等级：多项式算法、指数级算法
* 五个重要的策略：

## 2 对应的策略

* 将问题对应成另一个易于思考的问题
* A问题->B问题  B有现成算法，从而求解

**例1.1**

* 哥尼斯堡七桥问题（一笔画问题，七桥四块陆地）
* 从一块陆地出发，每次过一桥，且只能过一次，最后回到出发点，问是否存在这样的途径
* 哥尼斯堡七桥问题->欧拉回路
* 结论：从图上的一点出发又回到该点，连接该点的线（边）必须是偶数才能满足条件。
* 而七桥问题中，所有定点的度（连结边的条数）皆为奇数，故无解

    ![image](https://cloud.githubusercontent.com/assets/7693440/11355182/0182fe34-928e-11e5-8281-23681d8c7ff4.png)

**例1.2**

一种游戏，给出n(n为自然数），然后给出2n个自然数，例如n=4，2n=8个数是7 9 3 6 4 2 5 3，游戏双方为A，B（计算机）只允许从给出数列的两头取数，以取完数之和最大者为胜，A可以先取，如两者和相等仍算A胜

**方案1**
```cpp
	第一步 A取7
	            B取9 余3 6 4 2 5 3
	第二步 A取右3
	            B取5 余3 6 4 2 
	第三步 A取2
	            B取4 余3 6
	第四步 A取6
	            B取3
    结果：A=7+3+2+6=18 A输
               B=9+5+4+3=21
```

观察2n个数，奇偶为上述数之和有大小之分，取偶数位位置可获胜 
```cpp
    ① ② ③ ④ ⑤ ⑥ ⑦ ⑧
    7 9 3 6 4 2 5 3
```
A取 3 9 2 6 A胜
B取 7 5 4 3
取数问题对应成按奇偶对应规则取数可获问题解

**方案2**
```cpp
	第一步 A取7
	            B取9 余3 6 4 2 5 3
	第二步 A取左3
	            B取6 余4 2 5 3
	第三步 A取4
	            B取2 余5 3
	第四步 A取5
	            B取3
    结果：A=7+3+4+5=19 A输
               B=9+6+2+3=20
```

## 3 大化小的策略（分治策略）

* 规模大问题，求解较难，将规模大问题化为若干规模较小问题来求解，然后进行结果归并，这种即为分治策略。

**例1.3**

求一组数的最大值和最小值
设数的个数为n（规模参数），存在数组A[1]…A[n]

算法：
```cpp
min:=A[1];
max:=A[1];
for i:=2 to n do
begin
   if A[i]>max then max:=A[i];
   if A[i]< min then min:=A[i];
end;
```

* 对于n>2的规模，采用一分为二缩小其规模，最后结果必分为规模n=1或n=2的情况，则最后用一次比较可求出max，min，再进行归纳，最大值中归并出最大值，最小值中归并出最小值
* n=1时，`max=min=A[1]`;
* n=2时，
```cpp
if A[1]>=A[2] then
	min:=A[2];max:=A[1];
else
	max:=A[2];min:=A[1];
```
* 上例中i从2开始，每个数要比较两次方能决定到i的最大和最小值，采用分治方法，比较次数可减少
* 如n=4，只用比较4次
* 本例赋具体值
```cpp
N=9，A[1]…A[9]为（随意）
22    13    -5    -8   15   60   17   31   47
```

* 分治算法：取中值（两分法）mid:=(i+j) div 2（i，j）为数组元素上下标的上下界

* 分治求最大最小值过程max,min有4个形参：数组起始下标，终点下表，max,min变量。

![image](https://cloud.githubusercontent.com/assets/7693440/11358355/d42e2f4e-92ab-11e5-9222-4c837c17dae0.png)

* 归并

![image](https://cloud.githubusercontent.com/assets/7693440/11358366/f09711fa-92ab-11e5-9370-ad0d58a56bfb.png)

* 不用分治法，n=9，比较2*(n-1)=16次
* 采用分治法：分治时用4次，归并时用2*4=8次，共4+2*4=12次

## 4 归纳的策略（递归的思想）

* Hanoi 汉诺塔问题
* A柱盘子（上小下大）移到C，有B柱作中间转换，开始时B、C无盘子
* N=1，搬1次，A->1->C
* N=2，搬3次，A->1->B，A->2->C，B->1->C
* N=3，搬7次

**归纳：**
* N=1，A柱的一个盘->C
* N>1：
	* A柱的(N-1)个盘->B
	* 剩下一个盘->C
	* B盘重复将(N-1)个盘->C
	* 即源柱(A)，工作柱(B)，目的柱(C)

**归纳算法**

```cpp
If n=1，将1个盘搬到C，结束，否则2
递归
	A（源）(n-1)个盘->B，以B为工作柱
	将A最后一个盘->C
	将B柱的(n-1)个盘->A，以A为工作柱
```
## 5 制定目标策略

* 建立目标策略
* 典型背包问题
* 例：假设一个能装20份容器的背包，去批发甲、乙、丙三种货物，如
```CPP
买甲货，全部获利252元，占背包18份容量
买乙货，全部获利240元，占背包15份容量，
买丙货，全部获利150元，占背包10份容量。
```
试问各买多少获利最多。

![image](https://cloud.githubusercontent.com/assets/7693440/11358426/ade7aa44-92ac-11e5-8e11-89469764c947.png)

* 分析：采购三种货物性能价格比
甲：252/18=14，乙：240/15=16，丙150/10=15
方案2 最优，因为乙性能价格比最高  

* 将上例的量一般化
* 设n种货物，第i种货物编号为Bi，全部购获利Pi，但需占背包容量Wi (i=1,2,..,n)，若背包总容量为M，求最大获利方案
* 数据结构   
![image](https://cloud.githubusercontent.com/assets/7693440/11358436/d2f26f7c-92ac-11e5-816b-9a6b904d57b1.png)

* 建立目标函数Pi / Wi（性能价格比），并对目标函数Pi/Wi排序，获Pi/Wi由小到大排序的顺序表，可获解

## 6 枚举的策略

* 当找不到更好的途径时，可根据部分条件（约束条件）将可能的情况列举，然后验证，枚举时尽可能将明显的不是解的情况排除，以尽可能减少枚举的可能的数目

## 7 作业

* 1020 大数求模
* 1021 简单题 -> 规模原来很大 -> 难 ->数据结构: 栈
* 1027 简单题
* 1035 简单题
* 1046 排序
* 1051 简单题
* 1198 8个串排出最小字典序(8!枚举）
* 1176 两人从两头取数

